package MVC.Model.DungeonItems;

import MVC.Model.DungeonUtils.Graph;
import MVC.Model.Physics.Vec2;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Dungeon implements Serializable
{
    /**
     * list of the rooms with the coordiantes
     */
    private List<Room> myRooms;

    /**
     * the dimension of the dungeon, x by x
     */
    private int myDimension;

    /**
     * Default constructor for the dungeon instruction set
     */
    public Dungeon()
    {
        myDimension = 4;
        myRooms = generateRooms(myDimension);
        myRooms = generateDungeonFromRooms(myRooms,myDimension);
    }

    /**
     * @param theDimension of the Dungeon
     */
    public Dungeon(final int theDimension)
    {
        if(theDimension<=2)
        {
            System.out.println("Minimum Dimension for the dungeon is 3 by 3. We are setting up the 4 by 4 maze");
            myDimension = 4;
        }
        else
        {
            myDimension = theDimension;
        }
        myRooms = generateRooms(myDimension);
        myRooms = generateDungeonFromRooms(myRooms,myDimension);
    }

    /**
     * @param theDimension intended dimensions of the dungeon
     * @param theRooms intended list of rooms that are to be populated with the cartesian coordinates
     * @return sets the Rooms' entrances directions and positions according to the map generated by the Kruskal
     */
    public List<Room> generateDungeonFromRooms(final List<Room> theRooms, final int theDimension)
    {
        var edges = Graph.generateMaze(theDimension);
        //System.out.println(edges.size());
        var offset = theDimension+2;
        int src;
        int dest;
        for (int i = 0; i < edges.size(); i++)
        {
            src = edges.get(i).getSrc()-offset;
            dest = edges.get(i).getDest()-offset;
            if(src > dest)
            {
                var temp = src;
                src = dest;
                dest = temp;
            }

            if(src==dest-1)
            {
                for (int j = 0; j < theRooms.size(); j++)
                {
                    if(theRooms.get(j).getNumber()==src)
                    {
                        theRooms.get(j).setE(true);
                        theRooms.get(j+1).setW(true);
                    }
                }
            }
            else if (src==dest-offset)
            {
                for (int j = 0; j < theRooms.size(); j++)
                {
                    if(theRooms.get(j).getNumber()==src)
                    {
                        theRooms.get(j).setN(true);
                        theRooms.get(j+theDimension).setS(true);
                    }
                }
            }
        }

        for (var room:theRooms)
        {
            room.populateTheRoom(false);
        }
        return theRooms;
    }

    /**
     * @param theN intended dimensions of the dungeon, sqrt of the amount of rooms
     * @return Rooms where each room was modified, by setting
     * the Rooms' entrances directions and positions according to the map generated by the Kruskal
     */
    public static ArrayList<Room> generateRooms(final int theN)
    {
        var arr = new ArrayList<Room>();
        // Number of rooms + boundary rooms
        int allVertices = (int) Math.pow((Math.sqrt(theN*theN)+2),2);

        for (int i = 1; i < ((theN+2)*theN)-1; i++)
        {
            //Skip buffer rooms
            if(i % Math.sqrt(allVertices) == Math.sqrt(allVertices)-1 || i % Math.sqrt(allVertices) == 0)
            {
                continue;
            }

            //Account for the buffer offset
            //Adjust for positive value library coordinate system
            int row = (i / (theN + 2));
            int col = (i % (theN + 2)) - 1;
            arr.add(new Room(i, new Vec2(col,row)));
        }

        arr.get(0).setEntranceStatus(true);
        var exit = new Random().nextInt(1,arr.size());
        arr.get(exit).setExitStatus(true).addItem("exit");

        var notTaken = new ArrayList<Integer>();

        for (int i = 1; i < arr.size(); i++)
        {
            if(i != exit)
            {
            notTaken.add(i);
            }
        }

        for (int i = 0; i < 4; i++)
        {
            var randomIndex = new Random().nextInt(0,notTaken.size());
            var room = arr.get(notTaken.get(randomIndex));
            room.addItem("pillar");
            notTaken.remove(randomIndex);
        }

        return arr;
    }

    /**
     * @return the rooms of the dungeon
     */
    public List<Room> getRooms()
    {
        return myRooms;
    }

    /**
     * @return the dimensions of the dungeon
     */
    public int getDimension()
    {
        return myDimension;
    }

    /**
     * @param theRooms the new rooms of the dungeon
     */
    public void setRooms(final List<Room> theRooms)
    {
        myRooms = theRooms;
    }
}